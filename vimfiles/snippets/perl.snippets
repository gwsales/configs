snippet eif
	elsif (${1}) {
		${2:# Code}
	}
snippet els
	else {
		${1:# Code}
	}
# #!/usr/bin/perl
snippet kloop
	while (my (${1:$key}, ${2:$value}) = each ${3:$hash}) {
		${4:# Code}
	}

snippet kloop2
	while (my (${1:$key}, ${2:$value}) = each ${3:%hash}) {
		while (my (${4:$key2}, ${5:$value2}) = each %$2) {
			${6:# Code}
		}
	}
snippet arg
	my (${1:Args}) = @_;${2}
snippet #!
	#!/usr/bin/env perl

	#  Setup perl
	use Modern::Perl;
snippet #!l
	#!/usr/bin/env perl

	#  Setup perl
	use Modern::Perl;


	#  Import
	use IRM::Logger qw/ get_named_loggers /;

	#  Create the logging
	my $logger = get_named_loggers('${1:log}', qw/ ${2:debug  most  vis} /)${3};

# Hash Pointer
snippet .
	 =>
# Function
snippet sub
	sub ${1:function_name} {
		${2:#body ...}
	}
# Conditional
snippet if
	if (${1}) {
		${2:# body...}
	}
#Trinary conditional
snippet tri
	${1:assignment}  =  ${2:test}  ?  ${3:true}  :  ${4:false}
# Conditional if..else
snippet ife
	if (${1}) {
		${2:# body...}
	}
snippet es
	elsif (${1}) {
		${2:# body...}
	}
snippet ee
	else {
		${3:# else...}
	}
snippet giv
	given( ${1:} ) {
		when ( ${2:cond} ) ${3:do}
		default {}
	}
snippet xwhe
	when( ${1:cond} ) { ${2:do} }
	${3:}
snippet whe
	when( ${1:cond} ) {
		${2:do}
	}
	${3:}
# Conditional if..elsif..else
snippet ifee
	if (${1}) {
		${2:# body...}
	}
	elsif (${3}) {
		${4:# elsif...}
	}
	else {
		${5:# else...}
	}
# Conditional One-line
snippet xif
	${1:expression}  if  ${2:condition};${3}
# Unless conditional
snippet unless
	unless (${1}) {
		${2:# body...}
	}
# Unless conditional One-line
snippet xunless
	${1:expression}  unless  ${2:condition};${3}
# Try/Except
snippet eval
	eval {
		${1:# do something risky...}
	};
	if ($@) {
		${2:# handle failure...}
	}
# Try
snippet try
	try {
		${1:Try}
	}
	catch {
		${2: Catch}
	}
# While Loop
snippet wh
	while (${1}) {
		${2:# body...}
	}
# While Loop One-line
snippet xwh
	${1:expression}  while  ${2:condition};${3}
# For Loop
#snippet for
#	for (my $${2:var} = 0; $$2 < ${1:count}; $$2${3:++}) {
#		${4:# body...}
#	}
# Foreach Loop
snippet for
	for  my $${1:x}  (@${2:array}) {
		${3:# body...}
	}
# Foreach Loop One-line
snippet xfor
	${1:expression}  for  @${2:array};${3}
# Package
#snippet cl
#	package ${1:ClassName};
#
#	use base qw(${2:ParentClass});
#
#	sub new {
#		my $class = shift;
#		$class = ref $class if ref $class;
#		my $self = bless {}, $class;
#		$self;
#	}
#
#	1;${3}
## Read File
#snippet slurp
#	my $${1:var};
#	{ local $/ = undef; local *FILE; open FILE, "<${2:file}"; $$1 = <FILE>; close FILE }${3}

snippet ldie
	$logger->die(qq{${1:message}})${2};
snippet ldebug
	$logger->debug(qq{${1:message}})  if  $logger->is_debug${2};
snippet linfo
	$logger->info(qq{${1:message}})${2};
snippet lnotice
	$logger->notice(qq{${1:message}})${2};
snippet lwarn
	$logger->warn(qq{${1:message}})${2};
snippet lerror
	$logger->error(qq{${1:message}})${2};

snippet ldies
	$logger->die(sprintf(qq{${1:message}}, ${2:args}))${3};
snippet ldebugs
	$logger->debug(sprintf(qq{${1:message}}, ${2:args}))  if  $logger->is_debug${3};
snippet linfos
	$logger->info(sprintf(qq{${1:message}}, ${2:args}))${3};
snippet lnotices
	$logger->notice(sprintf(qq{${1:message}}, ${2:args}))${3};
snippet lwarns
	$logger->warn(sprintf(qq{${1:message}}, ${2:args}))${3};
snippet lerrors
	$logger->error(sprintf(qq{${1:message}}, ${2:args}))${3};
